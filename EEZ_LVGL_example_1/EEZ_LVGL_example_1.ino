
/// EEZ_LVGL_example_1
/// simple example showing how to use EEZ Studio and LVGL in an Arduino projects
/// (c) Duncan Greenwood, M5767, Feb 2025, duncan_greenwood@hotmail.com

#include <lvgl.h>
#include <TFT_eSPI.h>
#include <EEPROM.h>

// header files generated by EEZ-Studio
#include "ui.h"
#include "screens.h"
#include "images.h"
#include "fonts.h"
#include "actions.h"
#include "vars.h"
#include "styles.h"
#include "ui.h"

#define BACKLIGHT_PIN 18

static const uint16_t screen_width  = 320;    // must match hardware and EEZ project settings
static const uint16_t screen_height = 480;

static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf[screen_width * screen_height / 10];

TFT_eSPI tft = TFT_eSPI(screen_width, screen_height);

uint16_t calibration_data[5];
void do_calibration(void);

///

void setup(void) {

  uint32_t stimer = millis();

  Serial.begin(115200);
  while (!Serial && millis() - stimer < 5000);

  Serial.printf("\n\nEEZ LVGL Arduino example 1\n");

  // initialise EEPROM
  EEPROM.begin(256);

  // read stored screen calibration data
  EEPROM.get(1, calibration_data);

  // init TFT driver library and screen
  tft.begin();
  tft.setRotation(2);
  tft.setTouch(calibration_data);
  tft.fillScreen(TFT_NAVY);
  tft.setTextColor(TFT_WHITE, TFT_NAVY);
  tft.print("Starting ...");

  // set display backlight
  analogWriteRange(100);
  analogWrite(BACKLIGHT_PIN, 75);     // 75%

  // calibrate touch screen if necessary
  if (EEPROM[0] != 99) {
    Serial.printf("touchscreen calibration required\n");
    do_calibration();
  }

  // init LVGL library
  lv_init();
  lv_disp_draw_buf_init(&draw_buf, buf, NULL, screen_width * screen_height / 10);

  // register the custom display function
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = screen_width;
  disp_drv.ver_res = screen_height;
  disp_drv.flush_cb = custom_display_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  // register the custom touchscreen handler
  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = custom_touchscreen_read;
  lv_indev_drv_register(&indev_drv);

  // init EEZ-Studio UI
  ui_init();

  Serial.printf("setup complete\n");
}

void loop(void) {

  // update LVGL
  lv_timer_handler();

  // update EEZ-Studio UI
  ui_tick();
}

/// custom LVGL function to flush display buffer to display hardware, using TFT_eSPI library

void custom_display_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {

  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);

  tft.startWrite();
  tft.setAddrWindow(area->x1, area->y1, w, h);
  tft.pushColors((uint16_t *)&color_p->full, w * h, true);
  tft.endWrite();

  lv_disp_flush_ready(disp);
}

/// custom LVGL function to get touchsreen state from TFT_eSPI library

void custom_touchscreen_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {

  uint16_t x, y;

  if (tft.getTouch(&x, &y)) {
    data->state = LV_INDEV_STATE_PR;
    data->point.x = x;
    data->point.y = y;
  } else {
    data->state = LV_INDEV_STATE_REL;
  }
}

/// screen calibration

void do_calibration(void) {

  tft.fillScreen(TFT_NAVY);
  tft.setCursor(75, 160);
  tft.print("Touch each corner in turn");
  tft.calibrateTouch(calibration_data, TFT_WHITE, TFT_NAVY, 15);
  EEPROM[0] = 99;
  EEPROM.put(1, calibration_data);
  EEPROM.commit();
  Serial.printf("calibration complete - rebooting\n");
  delay(500);
  rp2040.reboot();
}

/// implementation of action callback functions defined in actions.h

void action_button_1_pressed(lv_event_t *e) {

  int16_t val;
  char buffer[16];

  Serial.printf("button_1 pressed\n");

  val = atoi(lv_textarea_get_text(objects.textarea_1));
  ++val;
  sprintf(buffer, "%d", val);
  lv_textarea_set_text(objects.textarea_1, buffer);
}

//

void action_button_2_pressed(lv_event_t *e) {

  int16_t val;
  char buffer[16];

  Serial.printf("button_2 pressed\n");

  val = atoi(lv_textarea_get_text(objects.textarea_1));
  --val;
  sprintf(buffer, "%d", val);
  lv_textarea_set_text(objects.textarea_1, buffer);
}

//

void action_slider_1_value_changed(lv_event_t *e) {

  char buffer[32];
  int16_t val = lv_slider_get_value(objects.slider_1);
  Serial.printf("slider_1 value changed to %d\n", val);

  sprintf(buffer, "%d", val);
  lv_textarea_set_text(objects.textarea_1, buffer);

  sprintf(buffer, "Slider value = %d", val);
  status_message(buffer);
}

//

void action_textarea_1_focused(lv_event_t *e) {

  Serial.printf("textarea_1 focused\n");
  lv_keyboard_set_textarea(objects.keyboard_1, objects.textarea_1);
}

//

void action_textarea_1_defocused(lv_event_t *e) {

  Serial.printf("textarea_1 defocused\n");
  lv_keyboard_set_textarea(objects.keyboard_1, NULL);
}

//

void action_switch_1_value_changed(lv_event_t *e) {

  char buffer[32];
  bool switch_state = lv_obj_has_state(lv_event_get_current_target(e), LV_STATE_CHECKED);
  Serial.printf("switch_1 state changed to %u\n", switch_state);
  sprintf(buffer, "Switch is now %s", (switch_state ? "on" : "off"));
  status_message(buffer);
}

/// utility functions

void status_message(char *text) {

  lv_label_set_text(objects.label_2, text);
}
